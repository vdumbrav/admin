import { readdirSync, statSync, writeFileSync } from 'node:fs'
import { join, resolve } from 'node:path'

const GENERATED_ROOT = resolve('src/lib/api/generated')
const HEADER = [
  '/* eslint-disable */',
  '// --- AUTO-GENERATED BY update-api-barrel.ts ---',
  '',
].join('\n')

const exportLines = readdirSync(GENERATED_ROOT, { withFileTypes: true })
  .filter((entry) => entry.isDirectory())
  .sort((a, b) => a.name.localeCompare(b.name))
  .flatMap((entry) => buildExportsForDirectory(entry.name))

const content = `${HEADER}${exportLines.join('\n')}\n`

writeFileSync(join(GENERATED_ROOT, 'index.ts'), content, 'utf8')

function buildExportsForDirectory(directory: string): string[] {
  if (directory === 'model') {
    return ['export * from "./model";']
  }

  const ownFilePath = join(GENERATED_ROOT, directory, `${directory}.ts`)
  if (pathExists(ownFilePath)) {
    return [`export * from "./${directory}/${directory}";`]
  }

  const indexFilePath = join(GENERATED_ROOT, directory, 'index.ts')
  if (pathExists(indexFilePath)) {
    return [`export * from "./${directory}";`]
  }

  const nestedFiles = readdirSync(join(GENERATED_ROOT, directory))
    .filter((fileName) => fileName.endsWith('.ts'))
    .sort()
    .map((fileName) => {
      const nameWithoutExtension = fileName.replace(/\.ts$/, '')
      return `export * from "./${directory}/${nameWithoutExtension}";`
    })

  return nestedFiles
}

function pathExists(path: string): boolean {
  try {
    statSync(path)
    return true
  } catch (error: unknown) {
    if (isNodeError(error) && error.code === 'ENOENT') {
      return false
    }
    throw error
  }
}

function isNodeError(error: unknown): error is NodeJS.ErrnoException {
  return (
    Boolean(error) &&
    typeof error === 'object' &&
    'code' in (error as Record<string, unknown>)
  )
}
